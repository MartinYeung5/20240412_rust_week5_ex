# week5

## 實現：一個簡單的聲明宏並理解其代碼結構，和編譯過程
宏(marco)和函數(function)最大的區別就是它在調用時多了一個 !, 宏可以有可變數量的參數。

($($a:expr),*)
最外的圓括號 () 將整個宏模式包裹其中。在()內的第一個東西是 $()，在$()中會將與與其相匹配的類型的值傳入，然後用於代碼替換。在這里，模式 $a:expr 會匹配任何 Rust 表達式並給予一個名稱：$a。

$() 之後的逗號的 * 是指在 * 之前的表達式會被匹配零次或多次以上。

當我們使用 multiply_number_from_one!(1, 2, 3, 4) 來調用該宏時，$a 的模式會被匹配四次，分別是 1、2、3、4〝合共4次。

在 => 之後的代碼：

{
    { 1  $(*$a)* }
}

這里有2個位置需要注意，第1是在最前的數字"1"，這是表示$a 的模式的起始值會是1，由1開始作出轉變。
$(*$a)* 的最外面"*"是指要執行多次，而*$a就是指要乘a的意思，
所以
第一次執行是 1 * 1 ，及得出 1。
第二次執行是 1 * 2 ，及得出 2。
第三次執行是 2 * 3 ，及得出 6。
第四次執行是 6 * 4 ，及得出 24。
由於只有4個數字，所以完成 "*" 的任務，同時也完成整個任務。
